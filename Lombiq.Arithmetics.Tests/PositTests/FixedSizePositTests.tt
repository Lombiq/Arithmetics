<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ include file="FixedSizePositTestTemplateFileManager.ttinclude" #>

<#

var manager = TemplateFileManager.Create(this);

#>

<#
	var positSizes = new byte[] {8,16,32,64};
	var underLyingStructureName= new string[] {"byte", "ushort","uint","ulong","BitMask"};

for (var i = 0; i<3; i++){
	for(var MaximumExponentSize = 0; MaximumExponentSize <=4; MaximumExponentSize++){
		var structName = "Posit"+positSizes[i]+"_"+MaximumExponentSize;
		var maxValue = Math.Pow((1 << (1 << MaximumExponentSize)),positSizes[i]-2);
		// This is the biggest representable integer such that all smaller positive integers can also be exactly represented
		// by the given environment.
		long pIntMax = 0;
		double maxScaleFactor;
		for ( int n = positSizes[i]-2-MaximumExponentSize; n>=0 ;n--)
		{
			maxScaleFactor = Math.Pow((1 << (1 << MaximumExponentSize)), positSizes[i]-n-2-MaximumExponentSize) + (1<<MaximumExponentSize)-1;
			pIntMax =(long)1 << n;
			if (maxScaleFactor >= pIntMax) break;            
		}
		manager.StartNewFile("Posit"+positSizes[i]+"_"+MaximumExponentSize+"_Tests.cs");
#>
using NUnit.Framework;
using Shouldly;
using System.Diagnostics;
using System.Globalization;

namespace Lombiq.Arithmetics.Tests
{
	[TestFixture]
	class <#= structName#>Tests
	{
		[Test]
		public void <#= structName#>_IntConversionIsCorrect()
		{
			Assert.AreEqual(new <#= structName#>(0).PositBits, 0);
			Assert.AreEqual((int)new <#= structName#>(1), 1);
			Assert.AreEqual((int)new <#= structName#>(-1), -1);
			Assert.AreEqual((int)new <#= structName#>(3), 3);
			Assert.AreEqual((int)new <#= structName#>(-3), -3);
			Assert.AreEqual((int)new <#= structName#>(8), 8);
			Assert.AreEqual((int)new <#= structName#>(-16), -16);
			Assert.AreEqual((int)new <#= structName#>(1024), <#= 1024 > maxValue ? maxValue : 1024 #>);
			Assert.AreEqual((int)new <#= structName#>(-1024), <#= -1024 < -maxValue ? -maxValue : -1024 #>);

			<# if(i>0){ #>Assert.AreEqual((int)new <#= structName#>(int.MaxValue), <#= int.MaxValue > maxValue ? maxValue : int.MaxValue #>);
			Assert.AreEqual((int)new <#= structName#>(int.MinValue), <#= int.MinValue < -maxValue ? -maxValue : int.MinValue #>);
			Assert.AreEqual((int)new <#= structName#>(100), 100);<# } #>						
		}

		[Test]
		public void <#= structName#>_FloatConversionIsCorrect()
		{
			Assert.AreEqual(new <#= structName#>((float)0.0).PositBits, 0);
			
			Assert.AreEqual((float)new <#= structName#>((float)1.0), 1);
			Assert.AreEqual((float)new <#= structName#>((float)2.0), 2);
			Assert.AreEqual((float)new <#= structName#>((float)0.5), 0.5);
			Assert.AreEqual((float)new <#= structName#>((float)0.0625), 0.0625);

			Assert.AreEqual((float)new <#= structName#>((float)0.09375), 0.09375);
			Assert.AreEqual((float)new <#= structName#>((float)1.5), 1.5);
			Assert.AreEqual((float)new <#= structName#>((float)-0.09375),- 0.09375);
			Assert.AreEqual((float)new <#= structName#>((float)-1.5), -1.5);
			Assert.AreEqual((float)new <#= structName#>((float)6), 6);
			Assert.AreEqual((float)new <#= structName#>((float)-6), -6);
			<# if (maxValue > float.MaxValue)
			   {#>Assert.AreEqual((float)new <#= structName#>((float) <#=maxValue#>),float.NaN);
			Assert.AreEqual((float)new <#= structName#>((float) <#=-maxValue#>),float.NaN);
			   <# }else {#>Assert.AreEqual((float)new <#= structName#>((float) <#=maxValue#>),(float)<#=maxValue#>);
			Assert.AreEqual((float)new <#= structName#>((float) <#=-maxValue#>),(float)<#=-maxValue#>);<# }#>			
			}

		[Test]
		public void <#= structName#>_DoubleConversionIsCorrect()
		{
			Assert.AreEqual((double)new <#= structName#>(0.0).PositBits, 0);
			
			Assert.AreEqual(new <#= structName#>(double.Epsilon), new <#= structName#>(<#= structName#>.MinPositiveValueBitMask, true));

			Assert.AreEqual((double)new <#= structName#>(1.0), 1.0);
			Assert.AreEqual((double)new <#= structName#>(2.0), 2);
			Assert.AreEqual((double)new <#= structName#>(0.5), 0.5);
			Assert.AreEqual((double)new <#= structName#>(0.0625), 0.0625);

			Assert.AreEqual((double)new <#= structName#>(0.09375), 0.09375);
			Assert.AreEqual((double)new <#= structName#>(1.5), 1.5);
			Assert.AreEqual((double)new <#= structName#>(-0.09375),-0.09375);
			Assert.AreEqual((double)new <#= structName#>(-1.5), -1.5);
			Assert.AreEqual((double)new <#= structName#>(6), 6);
			Assert.AreEqual((double)new <#= structName#>(-6), -6);
			<# if (maxValue > double.MaxValue)
			   {#>Assert.AreEqual((double)new <#= structName#>( <#=maxValue#>),double.NaN);
			Assert.AreEqual((double)new <#= structName#>( <#=-maxValue#>),double.NaN);
			   <# }else {#>Assert.AreEqual((float)(double)new <#= structName#>( <#=maxValue#>),(float)<#=maxValue#>);
			Assert.AreEqual((float)(double)new <#= structName#>( <#=-maxValue#>),(float)<#=-maxValue#>);<# }#>			
		}
		
		[Test]
		public void <#= structName#>_AdditionIsCorrectForPositives()
		{
			var posit1 = new <#= structName#>(1);

			for (var i = 1; i < <#= pIntMax > 1000 ? 1000 : pIntMax #>; i++)
			{
				posit1 += 1;
			}
			((uint)posit1).ShouldBe((uint)new <#= structName#>(<#= pIntMax > 1000 ? 1000 : pIntMax #>));
		}

		[Test]
		public void <#= structName#>_AdditionIsCorrectForNegatives()
		{
			var posit1 = new <#= structName#>(<#= pIntMax > 1000 ? -500 : -pIntMax/2 #>);

			for (var i = 1; i < <#=pIntMax > 1000 ? 1000 : pIntMax #>; i++)
			{
				posit1 += 1;
			}
			((uint)posit1).ShouldBe((uint)new <#= structName#>(<#= pIntMax > 1000 ? 499 : pIntMax/2-1 #>));
		}

		[Test]
		public void <#= structName#>_AdditionIsCorrectForReals()
		{
			var posit1 = new <#= structName#>(0.015625);
			var posit2 = posit1 + posit1;
			posit2.ShouldBe(new <#= structName#>(0.03125));
			(posit1-posit2).ShouldBe(new <#= structName#>(-0.015625));
			(new <#= structName#>(1) - new <#= structName#>(0.1)).ShouldBe(new <#= structName#>(0.9));
			
			<# if (i>=1)
			   {#>(new <#= structName#>(10.015625) - new <#= structName#>(0.015625)).ShouldBe(new <#= structName#>(10));
			(new <#= structName#>(127.5) + new <#= structName#>(127.5)).ShouldBe(new <#= structName#>(255));
			(new <#= structName#>(-16.625) + new <#= structName#>(21.875)).ShouldBe(new <#= structName#>(-16.625 + 21.875));
			<# }#><# if (i>=2)
			   {#>(new <#= structName#>(0.00001) + new <#= structName#>(100)).ShouldBe(new <#= structName#>(100.00001));<# }#>  					
		}	

		[Test]
		public void <#= structName#>_MultiplicationIsCorrect()
		{
			 var posit1 = new <#= structName#>(1);
			 (posit1 * new <#= structName#>(0.015625)).ShouldBe(new <#= structName#>(0.015625));
			 (posit1 * new <#= structName#>(256)).ShouldBe(new <#= structName#>(256));
			 (-posit1 * new <#= structName#>(3)).ShouldBe(new <#= structName#>(-3));
			 (new <#= structName#>(2) * new <#= structName#>(0.015625)).ShouldBe(new <#= structName#>(0.03125));
			 (new <#= structName#>(4) * new <#= structName#>(16)).ShouldBe(new <#= structName#>(64));
			 (new <#= structName#>(-3) * new <#= structName#>(-4)).ShouldBe(new <#= structName#>(12));
			
		<# if (i>=1){#>	 (new <#= structName#>(127.5) * new <#= structName#>(2)).ShouldBe(new <#= structName#>(255));
			 (new <#= structName#>(-16.625) * new <#= structName#>(-4)).ShouldBe(new <#= structName#>(66.5));<# }#>
		<# if (i>=2)
		  {#>(new <#= structName#>(100) * new <#= structName#>(0.9)).ShouldBe(new <#= structName#>(90));
			 (new <#= structName#>(-0.95) * new <#= structName#>(-10000)).ShouldBe(new <#= structName#>(9500));
			 (new <#= structName#>(-0.995) * new <#= structName#>(100000)).ShouldBe(new <#= structName#>(-99500));<# }#>  					
		}	

		[Test]
		public void <#= structName#>_DivisionIsCorrect()
		{
			 var posit1 = new <#= structName#>(1);
			 (posit1 / new <#= structName#>(0)).ShouldBe(new <#= structName#>(<#= structName#>.NaNBitMask, true));
			 (new <#= structName#>(0.015625) / posit1).ShouldBe(new <#= structName#>(0.015625));
			 (new <#= structName#>(256) / posit1).ShouldBe(new <#= structName#>(256));
			 (new <#= structName#>(3) / -posit1).ShouldBe(new <#= structName#>(-3));
			 (new <#= structName#>(0.03125) / new <#= structName#>(2)).ShouldBe(new <#= structName#>(0.015625));
			 (new <#= structName#>(64) / new <#= structName#>(16)).ShouldBe(new <#= structName#>(4));
			 (new <#= structName#>(12) / new <#= structName#>(-4)).ShouldBe(new <#= structName#>(-3));
			
			 <# if (i>=1)
			   {#>(new <#= structName#>(252) / new <#= structName#>(2)).ShouldBe(new <#= structName#>(126));
			 (new <#= structName#>(66.5) / new <#= structName#>(-4)).ShouldBe(new <#= structName#>(-16.625));
			<# }#> <# if (i>=2)
			   {#>(new <#= structName#>(90) / new <#= structName#>(0.9)).ShouldBe(new <#= structName#>(100));
			 (new <#= structName#>(9200)  / new <#= structName#>(-10000)).ShouldBe(new <#= structName#>(-0.92));
			 (new <#= structName#>(-80800) / new <#= structName#>(1000)).ShouldBe(new <#= structName#>(-80.80));<# }#>  
		 }	

		[Test]
		public void <#= structName#>_SqrtIsCorrect()
		{
			 var posit1 = new <#= structName#>(1);
			 <#= structName#>.Sqrt(posit1).ShouldBe(posit1);
			 <#= structName#>.Sqrt(-posit1).ShouldBe(new <#= structName#>(<#= structName#>.NaNBitMask, true));
	 
			 (<#= structName#>.Sqrt(new <#= structName#>(4))).ShouldBe(new <#= structName#>(2));
			 (<#= structName#>.Sqrt(new <#= structName#>(64))).ShouldBe(new <#= structName#>(8));
			 (<#= structName#>.Sqrt(new <#= structName#>(0.25))).ShouldBe(new <#= structName#>(0.5));
			 
			 <# if (i>=1)
			   {#>(<#= structName#>.Sqrt(new <#= structName#>(100))).ShouldBe(new <#= structName#>(10));
			 (<#= structName#>.Sqrt(new <#= structName#>(144))).ShouldBe(new <#= structName#>(12));
			 (<#= structName#>.Sqrt(new <#= structName#>(896))).ShouldBe(new <#= structName#>(29.9332590942));
			<# }#>
			 
			 <# if (i>=2)
			   {#>(<#= structName#>.Sqrt(new <#= structName#>(10000))).ShouldBe(new <#= structName#>(100));			
			 (<#= structName#>.Sqrt(new <#= structName#>(999936))).ShouldBe(new <#= structName#>(999.967999));
			 <# if (MaximumExponentSize>3)	
					{#>(<#= structName#>.Sqrt(new <#= structName#>(308641358025))).ShouldBe(new <#= structName#>(555555));<# }#><# }#>
		}
		
		[Test]
		public void <#= structName#>_FusedSumIsCorrect()
		{
			//System.Console.WriteLine("<#= structName#> " +  <#= structName#>.QuireSize + " fs: "+  <#= structName#>.QuireFractionSize);
			var positArray = new <#= structName#>[257];
			positArray[0] = new <#= structName#>(-64);
			for(var i=1; i <= 256; i++) positArray[i] = new <#= structName#>(0.5);          
			
			Assert.AreEqual(<#= structName#>.FusedSum(positArray).PositBits, new <#= structName#>(64).PositBits);

			positArray[2] = new <#= structName#>(<#= structName#>.NaNBitMask, true);
			Assert.AreEqual(<#= structName#>.FusedSum(positArray).PositBits, positArray[2].PositBits);

			var positArray2 = new <#= structName#>[1281];
			positArray2[0] = new <#= structName#>(0);
			for(var i=1; i <= 1280; i++) positArray2[i] = new <#= structName#>(0.1);
			Assert.AreEqual(<#= structName#>.FusedSum(positArray2).PositBits, new <#= structName#>(128).PositBits);
		}

		[Test]
		public void <#= structName#>_FusedDotProductIsCorrect()
		{
			var positArray1 = new <#= structName #>[3];
			var positArray2 = new <#= structName #>[3];
			positArray1[0] = new <#= structName #>(1);
			positArray1[1] = new <#= structName #>(2);
			positArray1[2] = new <#= structName #>(3);

			positArray2[0] = new <#= structName #>(1);
			positArray2[1] = new <#= structName #>(2);
			positArray2[2] = new <#= structName #>(4);
			Assert.AreEqual(<#= structName #>.FusedDotProduct(positArray1, positArray2).PositBits, new <#= structName #>(17).PositBits);

			var positArray3 = new <#= structName #>[3];
			positArray3[0] = new <#= structName #>(-1);
			positArray3[1] = new <#= structName #>(2);
			positArray3[2] = new <#= structName #>(-100);
			Assert.AreEqual(<#= structName #>.FusedDotProduct(positArray1, positArray3), new <#= structName #>(-297));

			 var positArray4 = new <#= structName #>[3];
			positArray4[0] = new <#= structName #>(-1);
			positArray4[1] = new <#= structName #>(2);
			positArray4[2] = new <#= structName #>(<#= structName #>.MaxValueBitMask, true);
			Assert.AreEqual(<#= structName #>.FusedDotProduct(positArray1, positArray4), new <#= structName #>(<#= structName #>.MaxValueBitMask, true));
		}

		[Test]
		public void <#= structName#>_ConversionToOtherEnvsIsCorrect()
		{
<#for (var n = 0; n<3; n++){ 
	for(var MaxEs = 0; MaxEs<=4; MaxEs++){
		var destinationStructName = "Posit"+positSizes[n]+"_"+MaxEs;
		if (destinationStructName == structName) continue;#>

			Assert.AreEqual((<#= destinationStructName #>)new <#= structName #>(<#= structName #>.NaNBitMask, true), new <#= destinationStructName #>( <#= destinationStructName #>.NaNBitMask, true));	
			for(var i = 0; i < <#= positSizes[n] * 200 #>; i++){
				//System.Console.WriteLine("<#= destinationStructName #> : " + 0.01*i*i*i*<#= MaxEs + 1 #> + " i: " + i );
				Assert.AreEqual(((<#= destinationStructName #>)new <#= structName #>(0.01*i*i*i*<#= MaxEs + 1 #> )).PositBits, new <#= destinationStructName #>((double) new <#= structName #>(0.01*i*i*i*<#= MaxEs + 1 #>)).PositBits);	
			}

			for(var i = 0; i < <#= positSizes[n] * 100 #>; i++){
				//System.Console.WriteLine("<#= destinationStructName #> : " + (1.0-(1.0/(i+1))) + " i: " + i );
				Assert.AreEqual((<#= destinationStructName #>)new <#= structName #>(1.0-(1.0/(i+1))), new <#= destinationStructName #>((double) new <#= structName #>( 1.0-(1.0/(i+1))) ));	
			}
<#}#>
<# } #>
		}
	}
}
<#
	}
}
#>

<#

manager.Process();

#>