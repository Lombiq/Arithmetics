<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ include file="FixedSizePositTestTemplateFileManager.ttinclude" #>


<#

var manager = TemplateFileManager.Create(this);

#>

<#
	var positSizes = new byte[] {8,16,32,64};
	var underLyingStructureName= new string[] {"byte", "ushort","uint","ulong","BitMask"};


for (var i = 0; i<3; i++){
	for(var MaximumExponentSize = 0; MaximumExponentSize <=4; MaximumExponentSize++){
		var structName = "Posit"+positSizes[i]+"_"+MaximumExponentSize;
		var maxValue = Math.Pow((1 << (1 << MaximumExponentSize)),positSizes[i]-2);
		// This is the biggest representable integer such that all smaller positive integers can also be exactly represented
		// by the given environment.
		long pIntMax = 0;
		double maxScaleFactor;
		for ( int n = positSizes[i]-2-MaximumExponentSize; n>=0 ;n--)
		{
			maxScaleFactor = Math.Pow((1 << (1 << MaximumExponentSize)), positSizes[i]-n-2-MaximumExponentSize) + (1<<MaximumExponentSize)-1;
			pIntMax =(long)1 << n;
			if (maxScaleFactor >= pIntMax) break;            
		}
		manager.StartNewFile("Posit"+positSizes[i]+"_"+MaximumExponentSize+"_Tests.cs");
#>
using NUnit.Framework;
using Shouldly;
using System.Diagnostics;
using System.Globalization;

namespace Lombiq.Arithmetics.Tests
{
	[TestFixture]
	class <#= structName#>Tests
	{
		[Test]
		public void <#= structName#>_IntConversionIsCorrect()
		{
			Assert.AreEqual(new <#= structName#>(0).PositBits, 0);
			Assert.AreEqual((int)new <#= structName#>(1), 1);
			Assert.AreEqual((int)new <#= structName#>(-1), -1);
			Assert.AreEqual((int)new <#= structName#>(3), 3);
			Assert.AreEqual((int)new <#= structName#>(-3), -3);
			Assert.AreEqual((int)new <#= structName#>(8), 8);
			Assert.AreEqual((int)new <#= structName#>(-16), -16);
			Assert.AreEqual((int)new <#= structName#>(1024), <#= 1024 > maxValue ? maxValue : 1024 #>);
			Assert.AreEqual((int)new <#= structName#>(-1024), <#= -1024 < -maxValue ? -maxValue : -1024 #>);

			<# if(i>0){ #>
			Assert.AreEqual((int)new <#= structName#>(int.MaxValue), <#= int.MaxValue > maxValue ? maxValue : int.MaxValue #>);
			Assert.AreEqual((int)new <#= structName#>(int.MinValue), <#= int.MinValue < -maxValue ? -maxValue : int.MinValue #>);
			Assert.AreEqual((int)new <#= structName#>(100), 100);

			<# } #>						
		}

		[Test]
		public void <#= structName#>_FloatConversionIsCorrect()
		{
			Assert.AreEqual(new <#= structName#>((float)0.0).PositBits, 0);
			
			Assert.AreEqual((float)new <#= structName#>((float)1.0), 1);
			Assert.AreEqual((float)new <#= structName#>((float)2.0), 2);
			Assert.AreEqual((float)new <#= structName#>((float)0.5), 0.5);
			Assert.AreEqual((float)new <#= structName#>((float)0.0625), 0.0625);

			Assert.AreEqual((float)new <#= structName#>((float)0.09375), 0.09375);
			Assert.AreEqual((float)new <#= structName#>((float)1.5), 1.5);
			Assert.AreEqual((float)new <#= structName#>((float)-0.09375),- 0.09375);
			Assert.AreEqual((float)new <#= structName#>((float)-1.5), -1.5);
			Assert.AreEqual((float)new <#= structName#>((float)6), 6);
			Assert.AreEqual((float)new <#= structName#>((float)-6), -6);
			<# if (maxValue > float.MaxValue)
			   {#>Assert.AreEqual((float)new <#= structName#>((float) <#=maxValue#>),float.NaN);
			Assert.AreEqual((float)new <#= structName#>((float) <#=-maxValue#>),float.NaN);
			   <# }else {#>
			Assert.AreEqual((float)new <#= structName#>((float) <#=maxValue#>),(float)<#=maxValue#>);
			Assert.AreEqual((float)new <#= structName#>((float) <#=-maxValue#>),(float)<#=-maxValue#>);
				<# }#>			
			}
		[Test]
		public void <#= structName#>_DoubleConversionIsCorrect()
		{
			Assert.AreEqual((double)new <#= structName#>(0.0).PositBits, 0);
			
			Assert.AreEqual((double)new <#= structName#>(1.0), 1.0);
			Assert.AreEqual((double)new <#= structName#>(2.0), 2);
			Assert.AreEqual((double)new <#= structName#>(0.5), 0.5);
			Assert.AreEqual((double)new <#= structName#>(0.0625), 0.0625);

			Assert.AreEqual((double)new <#= structName#>(0.09375), 0.09375);
			Assert.AreEqual((double)new <#= structName#>(1.5), 1.5);
			Assert.AreEqual((double)new <#= structName#>(-0.09375),-0.09375);
			Assert.AreEqual((double)new <#= structName#>(-1.5), -1.5);
			Assert.AreEqual((double)new <#= structName#>(6), 6);
			Assert.AreEqual((double)new <#= structName#>(-6), -6);
			<# if (maxValue > double.MaxValue)
			   {#>Assert.AreEqual((double)new <#= structName#>( <#=maxValue#>),double.NaN);
			Assert.AreEqual((double)new <#= structName#>( <#=-maxValue#>),double.NaN);
			   <# }else {#>
Assert.AreEqual((float)(double)new <#= structName#>( <#=maxValue#>),(float)<#=maxValue#>);
			Assert.AreEqual((float)(double)new <#= structName#>( <#=-maxValue#>),(float)<#=-maxValue#>);
				<# }#>			
		}
		
		[Test]
		public void <#= structName#>_AdditionIsCorrectForPositives()
		{
			var posit1 = new <#= structName#>(1);

			for (var i = 1; i < <#= pIntMax > 1000 ? 1000 : pIntMax #>; i++)
			{
				posit1 += 1;
			}
			((uint)posit1).ShouldBe((uint)new <#= structName#>(<#= pIntMax > 1000 ? 1000 : pIntMax #>));
		}

		[Test]
		public void <#= structName#>_AdditionIsCorrectForNegatives()
		{
			var posit1 = new <#= structName#>(<#= pIntMax > 1000 ? -500 : -pIntMax/2 #>);

			for (var i = 1; i < <#=pIntMax > 1000 ? 1000 : pIntMax #>; i++)
			{
				posit1 += 1;
			}
			((uint)posit1).ShouldBe((uint)new <#= structName#>(<#= pIntMax > 1000 ? 499 : pIntMax/2-1 #>));
		}

		[Test]
		public void <#= structName#>_AdditionIsCorrectForReals()
		{
			var posit1 = new <#= structName#>(0.015625);
			var posit2 = posit1 + posit1;
			posit2.ShouldBe(new <#= structName#>(0.03125));
			(posit1-posit2).ShouldBe(new <#= structName#>(-0.015625));
			(new <#= structName#>(1) - new <#= structName#>(0.1)).ShouldBe(new <#= structName#>(0.9));
			
			<# if (i>=1)
			   {#>
			   (new <#= structName#>(10.015625) - new <#= structName#>(0.015625)).ShouldBe(new <#= structName#>(10));
			   (new <#= structName#>(127.5) + new <#= structName#>(127.5)).ShouldBe(new <#= structName#>(255));
			   (new <#= structName#>(-16.625) + new <#= structName#>(21.875)).ShouldBe(new <#= structName#>(-16.625 + 21.875));
			<# }#>
			<# if (i>=2)
			   {#>
			   (new <#= structName#>(0.00001) + new <#= structName#>(100)).ShouldBe(new <#= structName#>(100.00001));
			<# }#>  					
		}	

		[Test]
		public void <#= structName#>_MultiplicationIsCorrect()
		{
			var posit1 = new <#= structName#>(1);
			 (posit1 * new <#= structName#>(0.015625)).ShouldBe(new <#= structName#>(0.015625));
			 (posit1 * new <#= structName#>(256)).ShouldBe(new <#= structName#>(256));
			 (-posit1 * new <#= structName#>(3)).ShouldBe(new <#= structName#>(-3));
			 (new <#= structName#>(2) * new <#= structName#>(0.015625)).ShouldBe(new <#= structName#>(0.03125));
			 (new <#= structName#>(4) * new <#= structName#>(16)).ShouldBe(new <#= structName#>(64));
			 (new <#= structName#>(-3) * new <#= structName#>(-4)).ShouldBe(new <#= structName#>(12));
			
			<# if (i>=1)
			   {#>
			   (new <#= structName#>(127.5) * new <#= structName#>(2)).ShouldBe(new <#= structName#>(255));
			   (new <#= structName#>(-16.625) * new <#= structName#>(-4)).ShouldBe(new <#= structName#>(66.5));
			<# }#>
			<# if (i>=2)
			   {#>
			   	(new <#= structName#>(100) * new <#= structName#>(0.9)).ShouldBe(new <#= structName#>(90));
			   	(new <#= structName#>(-0.95) * new <#= structName#>(-10000)).ShouldBe(new <#= structName#>(9500));
				(new <#= structName#>(-0.995) * new <#= structName#>(100000)).ShouldBe(new <#= structName#>(-99500));
			<# }#>  					
		}	
		[Test]
		public void <#= structName#>_DivisionIsCorrect()
		{
			 var posit1 = new <#= structName#>(1);
			 (new <#= structName#>(0.015625) / posit1).ShouldBe(new <#= structName#>(0.015625));
			 (new <#= structName#>(256) / posit1).ShouldBe(new <#= structName#>(256));
			 (new <#= structName#>(3) / -posit1).ShouldBe(new <#= structName#>(-3));
			 (new <#= structName#>(0.03125) / new <#= structName#>(2)).ShouldBe(new <#= structName#>(0.015625));
			 (new <#= structName#>(64) / new <#= structName#>(16)).ShouldBe(new <#= structName#>(4));
			 (new <#= structName#>(12) / new <#= structName#>(-4)).ShouldBe(new <#= structName#>(-3));
			
			<# if (i>=1)
			   {#>
			 (new <#= structName#>(252) / new <#= structName#>(2)).ShouldBe(new <#= structName#>(126));
			 (new <#= structName#>(66.5) / new <#= structName#>(-4)).ShouldBe(new <#= structName#>(-16.625));
			<# }#>
			<# if (i>=2)
			   {#>
			 (new <#= structName#>(90) / new <#= structName#>(0.9)).ShouldBe(new <#= structName#>(100));
			 (new <#= structName#>(9500)  / new <#= structName#>(-10000)).ShouldBe(new <#= structName#>(-0.95));
			 (new <#= structName#>(-80900) / new <#= structName#>(100000)).ShouldBe(new <#= structName#>(-0.809));
		 	<# }#>  
		 }										
	}
}
<#
	}
}
#>

<#

manager.Process();

#>