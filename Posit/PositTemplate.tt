<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ include file="PositTemplateFileManager.ttinclude" #>
<#@ assembly name="netstandard" #>
<#@ assembly name="$(TargetPath)" #>
<#@ import namespace="Lombiq.Arithmetics" #>
<# 
var templateFileManager = TemplateFileManager.Create(this);
var positSizes = new byte[] { 8, 16, 32, 64 };
var underlyingStructNames = new string[] { "byte", "ushort", "uint", "ulong", "BitMask" };

for (var i = 0; i < 3; i++)
{
    for (var maximumExponentSize = 0; maximumExponentSize <= 4; maximumExponentSize++)
    {
        var positSize = positSizes[i];
        var underlyingStructName = underlyingStructNames[i];
        var positStructName = PositTemplateHelper.GetPositStructName(positSize, maximumExponentSize);
        var quireSize = 1;

        while (quireSize < (4 * positSize - 8) * (1 << maximumExponentSize) + 31)
        {
             quireSize <<= 1;
        }

        templateFileManager.StartNewFile($"{positStructName}.cs");
 #>
using System;
using System.Runtime.CompilerServices;

namespace Lombiq.Arithmetics
{
    public readonly struct <#= positStructName #> : IComparable, IConvertible, IFormattable, IEquatable<<#= positStructName #>>, IComparable<<#= positStructName #>>
    {
        public <#= underlyingStructName #> PositBits { get; }

        #region Posit structure

        public const byte MaximumExponentSize = <#= maximumExponentSize #>;

        public const byte Size = <#= positSize #>;

        public const uint Useed = 1 << (1 << MaximumExponentSize);

        public const byte FirstRegimeBitIndex = Size - 2;

        public const byte FirstRegimeBitPosition = Size - 1;

        public const byte SizeMinusFixedBits = Size - 2 - MaximumExponentSize;

        public const ushort QuireSize = <#= quireSize #>;

        public const short QuireFractionSize = ((4 * Size) - 8) * (1 << MaximumExponentSize) / 2;

        #endregion

        #region Posit Masks

        public const <#= underlyingStructName #> SignBitMask = (<#= underlyingStructName #>)1 << (Size - 1);

        public const <#= underlyingStructName #> FirstRegimeBitBitMask = 1 << (Size - 2);

        public const <#= underlyingStructName #> EmptyBitMask = 0;

        public const <#= underlyingStructName #> MaxValueBitMask = <#= underlyingStructName #>.MaxValue - SignBitMask;

        public const <#= underlyingStructName #> MinPositiveValueBitMask = 1;

        public const <#= underlyingStructName #> NaNBitMask = SignBitMask;

        public const uint Float32ExponentMask = 0x_7f80_0000;

        public const uint Float32FractionMask = 0x_007f_ffff;

        public const uint Float32HiddenBitMask = 0x_0080_0000;

        public const uint Float32SignBitMask = 0x_8000_0000;

        public const ulong Double64FractionMask = 0x000F_FFFF_FFFF_FFFF;

        public const ulong Double64ExponentMask = 0x7FF0_0000_0000_0000;

        public const ulong Double64HiddenBitMask = 0x0010_0000_0000_0000;

        #endregion

        #region Posit constructors

        public <#= positStructName #>(<#= underlyingStructName #> bits, bool fromBitMask) =>
            PositBits = fromBitMask ? bits : new <#= positStructName #>(bits).PositBits;

        public <#= positStructName #>(Quire q)
        {
            PositBits = NaNBitMask;
            var sign = false;
            var positionOfMostSigniFicantOne = QuireSize - 1;
            var firstSegment = (ulong)(q >> (QuireSize - 64));

            if (firstSegment >= 0x8000_0000_0000_0000)
            {
                q = ~q;
                q += 1;
                sign = true;
            }

            firstSegment = (ulong)(q >> (QuireSize - 64));
            while (firstSegment < 0x8000_0000_0000_0000 && positionOfMostSigniFicantOne > 0)
            {
                q <<= 1;
                positionOfMostSigniFicantOne -= 1;
                firstSegment = (ulong)(q >> (QuireSize - 64));
            }

            var scaleFactor = positionOfMostSigniFicantOne - QuireFractionSize;
            if (positionOfMostSigniFicantOne == 0)
            {
                PositBits = 0;

                return;
            }

<# if (maximumExponentSize != 0)
{ #>
            var resultRegimeKValue = scaleFactor / (1 << MaximumExponentSize);
            var resultExponentBits = (<#= underlyingStructName #>)(scaleFactor % (1 << MaximumExponentSize));

            if (resultExponentBits < 0)
            {
                resultRegimeKValue -= 1;
                resultExponentBits += 1 << MaximumExponentSize;
            }

<# }
else // TODO: Check if this assignment should be a condition in the generated code rather than the template.
{ #>
            var resultRegimeKValue = scaleFactor;
<# } #>
            PositBits = AssemblePositBitsWithRounding(
                sign,
                resultRegimeKValue,
<# if (maximumExponentSize != 0)
{ #>
                resultExponentBits,
<# } #>
                (<#= underlyingStructName #>)(q >> (QuireSize - Size)));
        }

        public <#= positStructName #>(uint value)
        {
            if (value == 0)
            {
                PositBits = (<#= underlyingStructName #>)value;
                return;
            }

<# if (maximumExponentSize == 0)
{ #>
            var kValue = (byte)(PositHelper.GetMostSignificantOnePosition(value) - 1);
<# }
else
{ #>
            var exponentValue = (byte)(PositHelper.GetMostSignificantOnePosition(value) - 1);

            byte kValue = 0;
            while (exponentValue >= 1 << MaximumExponentSize && kValue < Size - 1)
            {
                exponentValue -= 1 << MaximumExponentSize;
                kValue++;
            }

<# } #>
            if (kValue > (Size - 2))
            {
                kValue = Size - 2;
<# if (maximumExponentSize != 0)
{ #>
                exponentValue = 0;
<# } #>
            }

            PositBits = AssemblePositBitsWithRounding(
                signBit: false,
                kValue,
<# if (maximumExponentSize != 0)
{ #>
                exponentValue,
<# } #>
                value);
        }

        public <#= positStructName #>(int value) =>
            PositBits = value >= 0
                ? new <#= positStructName #>((uint)value).PositBits
                : GetTwosComplement(new <#= positStructName #>((uint)-value).PositBits);

        public <#= positStructName #>(ulong value)
        {
            if (value == 0)
            {
                PositBits = (<#= underlyingStructName #>)value;

                return;
            }

<# if (maximumExponentSize == 0)
{ #>
            var kValue = (byte)(PositHelper.GetMostSignificantOnePosition(value) - 1);
<# }
else
{ #>
            var exponentValue = (byte)(PositHelper.GetMostSignificantOnePosition(value) - 1);

            byte kValue = 0;
            while (exponentValue >= 1 << MaximumExponentSize && kValue < Size - 1)
            {
                exponentValue -= 1 << MaximumExponentSize;
                kValue++;
            }

<# } #>
            if (kValue > (Size - 2))
            {
                kValue = Size - 2;
<# if (maximumExponentSize != 0)
{ #>
                exponentValue = 0;
<# } #>
            }

            PositBits = AssemblePositBitsWithRounding(
                signBit: false,
                kValue,
<# if (maximumExponentSize != 0)
{ #>
                exponentValue,
<# } #>
                value);
        }

        public <#= positStructName #>(long value) =>
            PositBits = value >= 0
                ? new <#= positStructName #>((ulong)value).PositBits
                : GetTwosComplement(new <#= positStructName #>((ulong)-value).PositBits);

        public <#= positStructName #>(float floatBits)
        {
            PositBits = NaNBitMask;

            if (float.IsInfinity(floatBits) || float.IsNaN(floatBits))
            {
                return;
            }

            if (floatBits == 0)
            {
                PositBits = 0;
                return;
            }

            uint uintRepresentation;
            unsafe
            {
                uint* floatPointer = (uint*)&floatBits;
                uintRepresentation = *floatPointer;
            }

            var signBit = (uintRepresentation & Float32SignBitMask) != 0;
            int scaleFactor = (int)((uintRepresentation << 1) >> 24) - 127;
            var fractionBits = uintRepresentation & Float32FractionMask;

            // Adding the hidden bit if it is one.
            if (scaleFactor != -127) fractionBits += Float32HiddenBitMask;
            else scaleFactor += 1;

<# if (maximumExponentSize != 0)
{ #>
            var regimeKValue = scaleFactor / (1 << MaximumExponentSize);

            if (scaleFactor < 0) regimeKValue--;

            var exponentValue = (<#= underlyingStructName #>)(scaleFactor - (regimeKValue * (1 << MaximumExponentSize)));
            if (exponentValue == 1 << MaximumExponentSize)
            {
                regimeKValue++;
                exponentValue = 0;
            }

            if (regimeKValue < -(Size - 1))
            {
                regimeKValue = -(Size - 1);
                exponentValue = 0;
            }

            if (regimeKValue > (Size - 2))
            {
                regimeKValue = Size - 2;
                exponentValue = 0;
            }
<# }
else 
{ #>
            var regimeKValue = scaleFactor;

            if (regimeKValue < -(Size - 1)) regimeKValue = -(Size - 1);

            if (regimeKValue > (Size - 2)) regimeKValue = Size - 2;
<# } #>

            PositBits = AssemblePositBitsWithRounding(
                signBit,
                regimeKValue,
<# if (maximumExponentSize != 0)
{ #>
                exponentValue,
<# } #>
                fractionBits);
        }

        public <#= positStructName #>(double doubleBits)
        {
            PositBits = NaNBitMask;

            if (double.IsInfinity(doubleBits) || double.IsNaN(doubleBits))
            {
                return;
            }

            if (doubleBits == 0)
            {
                PositBits = 0;

                return;
            }

            ulong ulongRepresentation;
            unsafe
            {
                ulong* doublePointer = (ulong*)&doubleBits;
                ulongRepresentation = *doublePointer;
            }

            var signBit = (ulongRepresentation & ((ulong)Float32SignBitMask << 32)) != 0;
            int scaleFactor = (int)((ulongRepresentation << 1) >> 53) - 1023;
            var fractionBits = ulongRepresentation & Double64FractionMask;
            // Adding the hidden bit if it is one.
            if (scaleFactor != -1023) fractionBits += Double64HiddenBitMask;
            else scaleFactor += 1;
<# if (maximumExponentSize != 0)
{ #>
            var regimeKValue = scaleFactor / (1 << MaximumExponentSize);
            if (scaleFactor < 0) regimeKValue--;

            var exponentValue = (<#= underlyingStructName #>)(scaleFactor - (regimeKValue * (1 << MaximumExponentSize)));
            if (exponentValue == 1 << MaximumExponentSize)
            {
                regimeKValue++;
                exponentValue = 0;
            }

            if (regimeKValue < -(Size - 1))
            {
                regimeKValue = -(Size - 1);
                exponentValue = 0;
            }

            if (regimeKValue > (Size - 2))
            {
                regimeKValue = Size - 2;
                exponentValue = 0;
            }
<# }
else 
{ #>
            var regimeKValue = scaleFactor;

            if (regimeKValue < -(Size - 1)) regimeKValue = -(Size - 1);

            if (regimeKValue > (Size - 2)) regimeKValue = Size - 2;
<# } #>

            PositBits = AssemblePositBitsWithRounding(
                signBit,
                regimeKValue,
<# if (maximumExponentSize != 0)
{ #>
                exponentValue,
<# } #>
                fractionBits);
        }

        #endregion

        #region Posit constructors for Posit conversions

<# for(var n = i; n < 3; n++)
{
if (maximumExponentSize == 0)
{ #>
        public <#= positStructName #>(bool sign, short scaleFactor, <#= underlyingStructNames[n] #> fraction) =>
            PositBits = AssemblePositBitsWithRounding(sign, scaleFactor, fraction);
<# 
}
else
{ #>
        public <#= positStructName #>(bool sign, short scaleFactor, <#= underlyingStructNames[n] #> fraction)
        {
            var resultRegimeKValue = scaleFactor / (1 << MaximumExponentSize);
            var resultExponentBits = scaleFactor % (1 << MaximumExponentSize);

            if (resultExponentBits < 0)
            {
                resultRegimeKValue -= 1;
                resultExponentBits += 1 << MaximumExponentSize;
            }

            PositBits = AssemblePositBitsWithRounding(
                sign,
                resultRegimeKValue,
                (<#= underlyingStructNames[n] #>)resultExponentBits,
                fraction);
        }
<# } #>

<# } #>
        #endregion

        #region Posit numeric states

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsPositive() => (PositBits & SignBitMask) == EmptyBitMask;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsNaN() => PositBits == NaNBitMask;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsZero() => PositBits == EmptyBitMask;

        #endregion

        #region Methods to assemble Posits

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= underlyingStructName #>  EncodeRegimeBits(int regimeKValue)
        {
            <#= underlyingStructName #>  regimeBits;
            if (regimeKValue > 0)
            {
                regimeBits = (<#= underlyingStructName #>)((1 << regimeKValue + 1) - 1);
                regimeBits <<= Size - PositHelper.GetMostSignificantOnePosition(regimeBits) - 1;
            }
            else regimeBits =(<#= underlyingStructName #>)(FirstRegimeBitBitMask >> -regimeKValue);

            return regimeBits;
        }

        private <#= underlyingStructName #>  AssemblePositBits(bool signBit, int regimeKValue, <#= underlyingStructName #>  exponentBits, <#= underlyingStructName #>  fractionBits)
        {
            // Calculating the regime. 
            var wholePosit = EncodeRegimeBits(regimeKValue);

            // Attaching the exponent
            var regimeLength = PositHelper.LengthOfRunOfBits(wholePosit, FirstRegimeBitPosition);


            wholePosit += (<#= underlyingStructName #>)(exponentBits << SizeMinusFixedBits - regimeLength);

            var fractionMostSignificantOneIndex = PositHelper.GetMostSignificantOnePosition(fractionBits) - 1;

            // Hiding the hidden bit. (It is always one.) 
            fractionBits = PositHelper.SetZero(fractionBits, (ushort)fractionMostSignificantOneIndex);

            wholePosit += (<#= underlyingStructName #>)(fractionBits << SizeMinusFixedBits - fractionMostSignificantOneIndex - regimeLength);

            return signBit ? GetTwosComplement(wholePosit) : wholePosit;
        }
    
        
        public static <#= underlyingStructName #>  AssemblePositBitsWithRounding(bool signBit, int regimeKValue,<#= maximumExponentSize != 0 ? underlyingStructName + " exponentBits ," : "" #>  <#= underlyingStructName #> fractionBits)
        {
            
            if (regimeKValue >= Size-2)
            {
                return signBit? (<#= underlyingStructName #>)(SignBitMask+1) : MaxValueBitMask;
            }
            if (regimeKValue < -(Size-2))
            {
                return signBit?  <#= underlyingStructName #>.MaxValue : MinPositiveValueBitMask;
            }

            // Calculating the regime. 
            var wholePosit = EncodeRegimeBits(regimeKValue);

            // Attaching the exponent.
            var regimeLength = PositHelper.LengthOfRunOfBits(wholePosit, FirstRegimeBitPosition);

            var fractionMostSignificantOneIndex = PositHelper.GetMostSignificantOnePosition(fractionBits) - 1;

            // Hiding the hidden bit. (It is always one.) 
            fractionBits = PositHelper.SetZero(fractionBits, (ushort)fractionMostSignificantOneIndex);

            <# if (maximumExponentSize == 0)
               {
 #>
            <# } else
                { #>
                    <# if (maximumExponentSize == 1)
                        {
 #>

            var exponentShiftedLeftBy = (sbyte)SizeMinusFixedBits - regimeLength;
            wholePosit += exponentShiftedLeftBy >= 0 ? (<#= underlyingStructName #>) (exponentBits << exponentShiftedLeftBy) : (<#= underlyingStructName #>)(exponentBits >> -exponentShiftedLeftBy);
                    

            if (exponentShiftedLeftBy < 0)
            {			  
                if (exponentBits == 1)
                {
                    if (fractionBits > 0)
                    {
                        wholePosit += 1;
                    }
                    else wholePosit += (byte)(wholePosit & 1);
                }else  return signBit ? GetTwosComplement(wholePosit) : wholePosit;      
            }
                    <# 	} else
                          { #>
            var exponentShiftedLeftBy = (sbyte)SizeMinusFixedBits - regimeLength;
            wholePosit += exponentShiftedLeftBy >= 0 ? (<#= underlyingStructName #>) (exponentBits << exponentShiftedLeftBy) : (<#= underlyingStructName #>)(exponentBits >> -exponentShiftedLeftBy);

            // Calculating rounding.
            if (exponentShiftedLeftBy < 0)
            {
                //if (exponentShiftedLeftBy <= SizeMinusFixedBits) exponentBits <<= Size + exponentShiftedLeftBy;
                //else exponentBits >>= Size + exponentShiftedLeftBy;
                exponentBits <<= Size + exponentShiftedLeftBy;

                if (exponentBits < SignBitMask) return signBit ? GetTwosComplement(wholePosit) : wholePosit;

                if ((exponentBits == SignBitMask) && fractionBits == 0) wholePosit += (<#= underlyingStructName #>)(wholePosit & 1);
                else wholePosit += 1;

                return signBit ? GetTwosComplement(wholePosit) : wholePosit;
            }
                        
                        <# } #>
            <# } #>
            

            var fractionShiftedLeftBy = SizeMinusFixedBits - (fractionMostSignificantOneIndex) - (regimeLength);
            // Attaching the fraction.
            wholePosit += fractionShiftedLeftBy >= 0 ? (<#= underlyingStructName #>)(fractionBits << fractionShiftedLeftBy) : (<#= underlyingStructName #>)(fractionBits >> -fractionShiftedLeftBy);
            // Calculating rounding.
            if (fractionShiftedLeftBy < 0)
            {
                if (Size + fractionShiftedLeftBy >= 0) fractionBits <<= Size + fractionShiftedLeftBy;
                else fractionBits >>= -(Size + fractionShiftedLeftBy);
                //return !signBit ? wholePosit : GetTwosComplement(wholePosit);
                if (fractionBits >= SignBitMask)
                {
                    if (fractionBits == SignBitMask)
                    {
                        wholePosit += (<#= underlyingStructName #>)(wholePosit & 1);
                    }
                    else wholePosit += 1;
                }
            }

            return signBit ? GetTwosComplement(wholePosit) : wholePosit;
        }	

    <# for( var n=i+1; n<4; n++)
    { #>
        //This method is necessary for conversions from posits wiht bigger underlying structures. 
        public static <#= underlyingStructName #>  AssemblePositBitsWithRounding(bool signBit, int regimeKValue,<#= maximumExponentSize != 0 ? underlyingStructNames[n] + " exponentBits ," : "" #>  <#= underlyingStructNames[n] #> fractionBits)
        {
            
            if (regimeKValue >= Size - 2)
            {
                return signBit? (<#= underlyingStructName #>)(SignBitMask+1) : MaxValueBitMask;
            }
            if (regimeKValue < -(Size - 2))
            {
                return signBit?  <#= underlyingStructName #>.MaxValue : MinPositiveValueBitMask;
            }

            // Calculating the regime. 
            var wholePosit = EncodeRegimeBits(regimeKValue);

            // Attaching the exponent.
            var regimeLength = PositHelper.LengthOfRunOfBits(wholePosit, FirstRegimeBitPosition);

            var fractionMostSignificantOneIndex = PositHelper.GetMostSignificantOnePosition(fractionBits) - 1; //Will need to be careful with this (>= Size??)

            // Hiding the hidden bit. (It is always one.) 
            fractionBits = PositHelper.SetZero(fractionBits, (ushort)fractionMostSignificantOneIndex);
            <# if (maximumExponentSize == 0)
               { #>
            
            <# } else
                { #>
                    <# if (maximumExponentSize == 1)
                        { #>

                        var exponentShiftedLeftBy = (sbyte)SizeMinusFixedBits - regimeLength;
                        wholePosit += exponentShiftedLeftBy >= 0 ? (<#= underlyingStructName #>) (exponentBits << exponentShiftedLeftBy) : (<#= underlyingStructName #>)(exponentBits >> -exponentShiftedLeftBy);

                        // Calculating rounding.			
                        if (exponentShiftedLeftBy < 0) //Our only exponent bit is lost.
                        {
              
                            if (exponentBits == 1)
                            {
                                if (fractionBits > 0) //This is correct and should be tested in the case of other MaximumExponentSizes too.
                                {
                                    wholePosit += 1;
                                }else wholePosit +=  (<#= underlyingStructName #>)(wholePosit & 1);
                            }else  return signBit ? GetTwosComplement(wholePosit) : wholePosit;      
            
                        }
                    <# } else //MaximumExponentSize >=1
                          { #>
                                var exponentShiftedLeftBy = (sbyte)SizeMinusFixedBits - regimeLength; 
                                wholePosit += exponentShiftedLeftBy >= 0 ? (<#= underlyingStructName #>) (exponentBits << exponentShiftedLeftBy) : (<#= underlyingStructName #>)(exponentBits >> -exponentShiftedLeftBy);

                                // Calculating rounding.
                                if (exponentShiftedLeftBy < 0) //The exponent is shifted to the right, so no fraction bits will fit in the number
                                {
                                    exponentBits <<= Size + exponentShiftedLeftBy;  // This places the first exponent bit that won't fit to the Most Significant Position 

                                    if ((<#= underlyingStructName #>) exponentBits < SignBitMask) return signBit ? GetTwosComplement(wholePosit) : wholePosit; //The first non-fitting exponent bit is zero, so we dont round up.

                                    if (((<#= underlyingStructName #>)exponentBits == SignBitMask) && (fractionBits==0)) wholePosit += (<#= underlyingStructName #>)(wholePosit & 1); 
                                    else wholePosit += 1; //The first non fitting exponent bit is one, and the others are not all 0s, so we round up.

                                    return signBit ? GetTwosComplement(wholePosit) : wholePosit;
                                }

            
                    <# } #>
            <# } #>

            var fractionShiftedLeftBy = SizeMinusFixedBits - (fractionMostSignificantOneIndex) - (regimeLength);
            // Attaching the fraction.
            wholePosit += fractionShiftedLeftBy >= 0 ? (<#= underlyingStructName #>)(fractionBits << fractionShiftedLeftBy) : (<#= underlyingStructName #>)(fractionBits >> -fractionShiftedLeftBy); // The casts should be OK because fractionBits will still be testable to decide rounding. 
            // Calculating rounding.
            if (fractionShiftedLeftBy < 0) //There are lost fraction bits.
            {
                if (<#= positSizes[n] #> + fractionShiftedLeftBy >= 0) fractionBits <<=<#= positSizes[n] #>  + fractionShiftedLeftBy;
                else fractionBits >>= -(<#= positSizes[n] #>  + fractionShiftedLeftBy);
                //return !signBit ? wholePosit : GetTwosComplement(wholePosit);
                //fractionBits =(<#= underlyingStructName #>) (fractionBits & <#= underlyingStructName #>.MaxValue);
                if (fractionBits >= ((<#= underlyingStructNames[n] #>)1 << (<#= positSizes[n] #>-1)))
                {
                    if (fractionBits == ((<#= underlyingStructNames[n] #>)1 << (<#= positSizes[n] #>-1)))
                    {
                        wholePosit += (<#= underlyingStructName #>)(wholePosit & 1);
                    }
                    else wholePosit += 1;
                }
            }

            return signBit ? GetTwosComplement(wholePosit) : wholePosit;
    }	
<# } #>

    #endregion

    #region Methods to handle parts of the Posit 

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public sbyte GetRegimeKValue()
        {
            var bits = IsPositive() ? PositBits : GetTwosComplement(PositBits);
            var lengthOfRunOfBits = PositHelper.LengthOfRunOfBits(bits, FirstRegimeBitPosition);

            return (bits & FirstRegimeBitBitMask) == EmptyBitMask
                ? (sbyte)-lengthOfRunOfBits
                : (sbyte)(lengthOfRunOfBits - 1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public sbyte GetRegimeKValueWithoutSignCheck(byte lengthOfRunOfBits)
        {
            return (PositBits & FirstRegimeBitBitMask) == EmptyBitMask
                ? (sbyte)-lengthOfRunOfBits
                : (sbyte)(lengthOfRunOfBits - 1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public short CalculateScaleFactor()
        {
            var regimeKvalue = GetRegimeKValue();
            //return (int)((GetRegimeKValue() == 0) ? 1 + GetExponentValue() : (GetRegimeKValue() * (1 << MaximumExponentSize) + GetExponentValue()));
            return (regimeKvalue == -FirstRegimeBitPosition) ? (short)0 : (short)(regimeKvalue * (1 << MaximumExponentSize) <#= maximumExponentSize!=0 ? "+ GetExponentValue()" : "" #>);
        }

    
        <# if (maximumExponentSize !=0)
           { #>		 
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte ExponentSize()
        {
            var bits = IsPositive() ? PositBits : GetTwosComplement(PositBits);
            var lengthOfRunOfBits = PositHelper.LengthOfRunOfBits(bits, FirstRegimeBitPosition);
            byte result;
            if (lengthOfRunOfBits + 2 <= Size)
            {
                result = Size - (lengthOfRunOfBits + 2) > MaximumExponentSize
                     ? MaximumExponentSize : (byte)(Size - (lengthOfRunOfBits + 2));
            }
            else result = (byte)(Size - lengthOfRunOfBits - 1);
            return result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte ExponentSizeWithoutSignCheck()
        {
            var lengthOfRunOfBits = PositHelper.LengthOfRunOfBits(PositBits, FirstRegimeBitPosition);
            return Size - (lengthOfRunOfBits + 2) > MaximumExponentSize
                ? MaximumExponentSize : (byte)(Size - (lengthOfRunOfBits + 2));
        }		  

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetExponentValue()
        {
            var exponentMask = IsPositive() ? PositBits : GetTwosComplement(PositBits);
            var exponentSize = ExponentSize();
            exponentMask = (<#= underlyingStructName #>)((<#= underlyingStructName #>)((exponentMask >> (int)FractionSize())
                            << (Size - exponentSize))
                            >> (Size - MaximumExponentSize));
            return exponentSize == 0 ? (<#= underlyingStructName #>)0 : exponentMask;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetExponentValueWithoutSignCheck()
        {
            return (<#= underlyingStructName #>)((<#= underlyingStructName #>)((PositBits >> (int)FractionSizeWithoutSignCheck())
                            << (Size - ExponentSize()))
                            >> (Size - MaximumExponentSize));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetExponentValueWithoutSignCheck(uint fractionSize)
        {
            return (<#= underlyingStructName #>)((<#= underlyingStructName #>)((PositBits >> (int)fractionSize)
                            << (Size - ExponentSize()))
                            >> (Size - MaximumExponentSize));
        }
         <# } #>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint FractionSize()
        {
            var bits = IsPositive() ? PositBits : GetTwosComplement(PositBits);
            var fractionSize = Size - (PositHelper.LengthOfRunOfBits(bits, FirstRegimeBitPosition) + 2 + MaximumExponentSize);
            return fractionSize > 0 ? (uint)fractionSize : 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint FractionSizeWithoutSignCheck()
        {
            var fractionSize = Size - (PositHelper.LengthOfRunOfBits(PositBits, FirstRegimeBitPosition) + 2 + MaximumExponentSize);
            return fractionSize > 0 ? (uint)fractionSize : 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint FractionSizeWithoutSignCheck(byte lengthOfRunOfBits)
        {
            var fractionSize = Size - (lengthOfRunOfBits + 2 + MaximumExponentSize);
            return fractionSize > 0 ? (uint)fractionSize : 0;
        }

        #endregion

        #region Helper methods for operations and conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint Fraction()
        {
            var fractionSize = FractionSize();
            var bits = IsPositive() ? PositBits : GetTwosComplement(PositBits);
            return (<#= underlyingStructName #>)((<#= underlyingStructName #>)(bits << (int)(Size - fractionSize))
                          >> (int)(Size - fractionSize));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#= underlyingStructName #> FractionWithHiddenBit()
        {
            var fractionSize = FractionSize();
            var bits = IsPositive() ? PositBits : GetTwosComplement(PositBits);
            var result = (<#= underlyingStructName #>)((<#= underlyingStructName #>)(bits << (int)(Size - fractionSize))
                         >> (int)(Size - fractionSize));
            return fractionSize == 0 ? (<#= underlyingStructName #>)1 : PositHelper.SetOne(result, (ushort)fractionSize);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#= underlyingStructName #> FractionWithHiddenBit(uint fractionSize)
        {
            var bits = IsPositive() ? PositBits : GetTwosComplement(PositBits);
            var result = (<#= underlyingStructName #>)((<#= underlyingStructName #>)(bits << (int)(Size - fractionSize))
                         >> (int)(Size - fractionSize));
            return PositHelper.SetOne(result, (ushort)fractionSize);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#= underlyingStructName #> FractionWithHiddenBitWithoutSignCheck()
        {
            var fractionSizeWithoutSignCheck = FractionSizeWithoutSignCheck();
            var result = (<#= underlyingStructName #>)((<#= underlyingStructName #>)(PositBits << (int)(Size - fractionSizeWithoutSignCheck))
                         >> (int)(Size - fractionSizeWithoutSignCheck));
            return PositHelper.SetOne(result, (ushort)fractionSizeWithoutSignCheck);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#= underlyingStructName #> FractionWithHiddenBitWithoutSignCheck(uint fractionSize)
        {
            var numberOfNonFractionBits = (int)(Size - fractionSize);
            var result = (<#= underlyingStructName #>)((<#= underlyingStructName #>)(PositBits << numberOfNonFractionBits)
                         >> numberOfNonFractionBits);
            return PositHelper.SetOne(result, (ushort)fractionSize);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static short CalculateScaleFactor(sbyte regimeKValue <#= maximumExponentSize==0?"":", uint exponentValue" #> , byte MaximumExponentSize) =>
            (short)(regimeKValue * (1 << MaximumExponentSize) <#= maximumExponentSize==0?"":" + exponentValue" #>);

        public static Quire MultiplyIntoQuire(<#= positStructName #> left, <#= positStructName #> right)
        {

            if (left.IsZero() || right.IsZero()) return new Quire((ushort)QuireSize);
            if (left.IsNaN() || right.IsNaN()) return new Quire(1, (ushort)QuireSize) << (QuireSize - 1);
            var leftIsPositive = left.IsPositive();
            var rightIsPositive = right.IsPositive();
            var resultSignBit = leftIsPositive != rightIsPositive;

            left = Abs(left);
            right = Abs(right);
            var leftFractionSize = left.FractionSizeWithoutSignCheck();
            var rightFractionSize = right.FractionSizeWithoutSignCheck();

            var longResultFractionBits = (<#= underlyingStructNames[i+1] #>)(left.FractionWithHiddenBitWithoutSignCheck() *
                (ulong)right.FractionWithHiddenBitWithoutSignCheck());
            var fractionSizeChange = PositHelper.GetMostSignificantOnePosition(longResultFractionBits) - (leftFractionSize + rightFractionSize + 1);
            var scaleFactor =
                CalculateScaleFactor(left.GetRegimeKValue() <#= maximumExponentSize==0?"":", left.GetExponentValue()" #>, MaximumExponentSize) +
                CalculateScaleFactor(right.GetRegimeKValue()<#= maximumExponentSize==0?"":", right.GetExponentValue()" #>, MaximumExponentSize);

            scaleFactor += (int)fractionSizeChange;

            var quireArray = new ulong[QuireSize / 64];
            quireArray[0] = longResultFractionBits;
            var resultQuire = new Quire(quireArray);
            resultQuire <<= (QuireFractionSize - PositHelper.GetMostSignificantOnePosition(longResultFractionBits) + 1 + scaleFactor);

            return !resultSignBit ? resultQuire : (~resultQuire) + 1;
        }

        #endregion

        #region Bit level Helper Methods		

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= positStructName #> Abs(<#= positStructName #> input)
        {
            var signBit = input.PositBits >> Size - 1;
            var maskOfSignBits = 0 - signBit;
            return new <#= positStructName #>((<#= underlyingStructName #>)((input.PositBits ^ maskOfSignBits) + signBit), true);
        }		

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= underlyingStructName #> GetTwosComplement(<#= underlyingStructName #> bits) => (<#= underlyingStructName #>)(~bits + 1);

        #endregion

        #region Algebraic functions

        public static <#= positStructName #> Sqrt(<#= positStructName #> number)
        {
            if (number.IsNaN() || number.IsZero()) return number;
            if (!number.IsPositive()) return new <#= positStructName #>(NaNBitMask, true);

            var inputScaleFactor = number.CalculateScaleFactor(); 
            var inputFractionWithHiddenBit = (<#= underlyingStructNames[i+1] #>) number.FractionWithHiddenBitWithoutSignCheck();			

            <#= underlyingStructNames[i+1] #> resultFractionBits = 0; 
            <#= underlyingStructNames[i+1] #> startingEstimate = 0; 
            <#= underlyingStructNames[i+1] #> temporaryEstimate; 
            <#= underlyingStructNames[i+1] #> estimateMaskingBit = (<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>SignBitMask << (Size - 2)); 


            if ((inputScaleFactor & 1) != 0) // if the scaleFactor is odd, shift the number to make it even
            {
                inputScaleFactor -= 1;
                inputFractionWithHiddenBit += inputFractionWithHiddenBit;
                estimateMaskingBit <<= 1;
            }
            
            inputScaleFactor >>= 1;
            var shiftLeftBy = 2*Size - 2 - PositHelper.GetMostSignificantOnePosition(inputFractionWithHiddenBit);
            
            if (shiftLeftBy >= 0)
            {
                inputFractionWithHiddenBit <<= shiftLeftBy;

            }else
            {
                inputFractionWithHiddenBit <<= 1;

            }

            
            while (estimateMaskingBit != 0)
            {
                temporaryEstimate =(<#= underlyingStructNames[i+1] #>) (startingEstimate + estimateMaskingBit);
                if (temporaryEstimate <= inputFractionWithHiddenBit)
                {
                    startingEstimate = (<#= underlyingStructNames[i+1] #>)(temporaryEstimate + estimateMaskingBit);
                    inputFractionWithHiddenBit -= temporaryEstimate;
                    resultFractionBits += estimateMaskingBit;
                }

                inputFractionWithHiddenBit += inputFractionWithHiddenBit;
                estimateMaskingBit >>= 1;
            }
            
            <# if (maximumExponentSize !=0)
            { #>	
                var resultRegimeKValue = inputScaleFactor / (1 << MaximumExponentSize);
                var resultExponentBits = (inputScaleFactor % (1 << MaximumExponentSize));
                if (resultExponentBits < 0)
                {
                    resultRegimeKValue -= 1;
                    resultExponentBits += 1 << MaximumExponentSize;
                }
            <# } else
            { #>
                var resultRegimeKValue = inputScaleFactor;			
            <# } #>

                return new <#= positStructName #>(AssemblePositBitsWithRounding(false, resultRegimeKValue,  <#= maximumExponentSize != 0 ? "(" + underlyingStructName + ")" + " resultExponentBits," : "" #>  resultFractionBits), true);
        }

        #endregion

        #region Fused operations

        public static <#= positStructName #> FusedSum(<#= positStructName #>[] posits)
        {
            var resultQuire = new Quire((ushort)QuireSize);

            for (var i = 0; i < posits.Length; i++)
            {
                if (posits[i].IsNaN()) return posits[i];
                resultQuire += (Quire)posits[i];
            }

            return new <#= positStructName #>(resultQuire);
        }

        public static Quire FusedSum(<#= positStructName #>[] posits, Quire startingValue)
        {
            var quireNaNMask = new Quire(1, (ushort)QuireSize) << (QuireSize - 1);

            if (startingValue == quireNaNMask) return quireNaNMask;
            for (var i = 0; i < posits.Length; i++)
            {
                if (posits[i].IsNaN()) return quireNaNMask;
                startingValue += (Quire)posits[i];
            }

            return startingValue;
        }

        public static <#= positStructName #> FusedDotProduct(<#= positStructName #>[] positArray1, <#= positStructName #>[] positArray2)
        {
            if (positArray1.Length != positArray2.Length) return new <#= positStructName #>(NaNBitMask, true);

            var resultQuire = new Quire((ushort)QuireSize);

            for (var i = 0; i < positArray1.Length; i++)
            {
                if (positArray1[i].IsNaN()) return positArray1[i];
                if (positArray2[i].IsNaN()) return positArray2[i];
                resultQuire += MultiplyIntoQuire(positArray1[i], positArray2[i]);

            }

            return new <#= positStructName #>(resultQuire);
        }

        public static <#= positStructName #> FusedMultiplyAdd(<#= positStructName #> a, <#= positStructName #> b, <#= positStructName #> c)
        {
            var positArray1 = new <#= positStructName #>[2];
            var positArray2 = new <#= positStructName #>[2];

            positArray1[0] = a;
            positArray1[1] = new <#= positStructName #>(1);
            positArray2[0] = b;
            positArray2[1] = c;

            return FusedDotProduct(positArray1, positArray2);
        }

        public static <#= positStructName #> FusedAddMultiply(<#= positStructName #> a, <#= positStructName #> b, <#= positStructName #> c)
        {
            var positArray1 = new <#= positStructName #>[2];
            var positArray2 = new <#= positStructName #>[2];

            positArray1[0] = a;
            positArray1[1] = b;
            positArray2[0] = c;
            positArray2[1] = c;

            return FusedDotProduct(positArray1, positArray2);
        }

        public static <#= positStructName #> FusedMultiplyMultiplySubtract(<#= positStructName #> a, <#= positStructName #> b, <#= positStructName #> c, <#= positStructName #> d)
        {
            var positArray1 = new <#= positStructName #>[2];
            var positArray2 = new <#= positStructName #>[2];

            positArray1[0] = a;
            positArray1[1] = -c;
            positArray2[0] = b;
            positArray2[1] = d;

            return FusedDotProduct(positArray1, positArray2);
        }
        #endregion

        #region Arithmetic Operators       

        public static <#= positStructName #> operator +(<#= positStructName #> left, <#= positStructName #> right)
        {
            // Handling special cases first.
            if (left.IsNaN()) return left;
            if (right.IsNaN()) return right;
            if (left.IsZero()) return right;
            if (right.IsZero()) return left;

            var leftSignBit = left.PositBits >> Size - 1;
            var leftMaskOfSignBits = 0 - leftSignBit;
            var leftAbsoluteValue = new <#= positStructName #>((<#= underlyingStructName #>)((left.PositBits ^ leftMaskOfSignBits) + leftSignBit), true);

            var rightSignBit = right.PositBits >> Size - 1;
            var rightMaskOfSignBits = 0 - rightSignBit;
            var rightAbsoluteValue = new <#= positStructName #>((<#= underlyingStructName #>)((right.PositBits ^ rightMaskOfSignBits) + rightSignBit), true);

            var leftLengthOfRunOfBits = PositHelper.LengthOfRunOfBits(leftAbsoluteValue.PositBits, FirstRegimeBitPosition);
            var rightLengthOfRunOfBits = PositHelper.LengthOfRunOfBits(rightAbsoluteValue.PositBits, FirstRegimeBitPosition);

            var leftFractionSize = leftAbsoluteValue.FractionSizeWithoutSignCheck(leftLengthOfRunOfBits);
            var rightFractionSize = rightAbsoluteValue.FractionSizeWithoutSignCheck(rightLengthOfRunOfBits);

            var signBitsMatch = leftSignBit == rightSignBit;
            sbyte leftRegimeKValue = leftAbsoluteValue.GetRegimeKValueWithoutSignCheck(leftLengthOfRunOfBits);
            sbyte rightRegimeKValue = rightAbsoluteValue.GetRegimeKValueWithoutSignCheck(rightLengthOfRunOfBits);
            <# if (maximumExponentSize !=0)
               { #>               
            uint rightExponentValue = rightAbsoluteValue.GetExponentValueWithoutSignCheck(rightFractionSize);
            uint leftExponentValue = leftAbsoluteValue.GetExponentValueWithoutSignCheck(leftFractionSize);
            <# } #>

            var resultSignBit = leftAbsoluteValue > rightAbsoluteValue ? leftSignBit == 1 : rightSignBit == 1;
            <#= underlyingStructNames[i+1] #> resultFractionBits = 0;

            var leftScaleFactor = CalculateScaleFactor(leftRegimeKValue<#= maximumExponentSize==0?"":", leftExponentValue" #>, MaximumExponentSize);
            var rightScaleFactor = CalculateScaleFactor(rightRegimeKValue<#= maximumExponentSize==0?"":", rightExponentValue" #>, MaximumExponentSize);

            var scaleFactorDifference = leftScaleFactor - rightScaleFactor;

            var scaleFactor =
                scaleFactorDifference >= 0
                    ? leftScaleFactor
                    : rightScaleFactor;

            var leftFraction = leftAbsoluteValue.FractionWithHiddenBitWithoutSignCheck(leftFractionSize);
            var rightFraction = rightAbsoluteValue.FractionWithHiddenBitWithoutSignCheck(rightFractionSize);

            if (scaleFactorDifference == 0)
            {
                if (signBitsMatch)
                {
                    resultFractionBits += (<#= underlyingStructNames[i+1] #>)(<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>leftFraction + rightFraction);
                }
                else
                {
                    if (leftFraction >= rightFraction)
                    {
                        resultFractionBits += (<#= underlyingStructNames[i+1] #>)(<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>leftFraction - rightFraction);
                    }
                    else
                    {
                        resultFractionBits +=(<#= underlyingStructNames[i+1] #>) (<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>rightFraction - leftFraction);
                    }
                }

                scaleFactor += (short)(PositHelper.GetMostSignificantOnePosition(resultFractionBits) -
                              leftFractionSize - 1);
            }
            else if (scaleFactorDifference > 0) // The scale factor of the left Posit is bigger.
            {
                var fractionSizeDifference = (int)(leftFractionSize - rightFractionSize);
                resultFractionBits += <#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>leftFraction;
                var biggerPositMovedToLeft = (int)(2 * FirstRegimeBitPosition - leftFractionSize - 1);
                resultFractionBits <<= biggerPositMovedToLeft;
                var smallerPositMovedToLeft = biggerPositMovedToLeft - scaleFactorDifference + fractionSizeDifference;

                if (signBitsMatch)
                {
                    if (smallerPositMovedToLeft >= 0)
                    {
                        resultFractionBits +=(<#= underlyingStructNames[i+1] #>)(<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>rightFraction << smallerPositMovedToLeft);
                    }
                    else resultFractionBits +=(<#= underlyingStructNames[i+1] #>) (<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>rightFraction >> -smallerPositMovedToLeft);
                }
                else resultFractionBits -= smallerPositMovedToLeft >= 0
                        ? (<#= underlyingStructNames[i+1] #>)(<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>rightFraction << smallerPositMovedToLeft)
                        : (<#= underlyingStructNames[i+1] #>)(<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>rightFraction >> -smallerPositMovedToLeft);

                scaleFactor += (short)(PositHelper.GetMostSignificantOnePosition(resultFractionBits) - 2 * FirstRegimeBitPosition);
            }
            else // The scale factor of the right Posit is bigger.
            {
                var fractionSizeDifference = (int)(rightFractionSize - leftFractionSize);
                resultFractionBits += <#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>rightFraction;
                var biggerPositMovedToLeft = (int)(2 * FirstRegimeBitPosition - rightFractionSize - 1);
                resultFractionBits <<= biggerPositMovedToLeft;

                if (signBitsMatch)
                {
                    if (biggerPositMovedToLeft + scaleFactorDifference + fractionSizeDifference >= 0)
                    {
                        resultFractionBits += (<#= underlyingStructNames[i+1] #>)(<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>leftFraction << (biggerPositMovedToLeft + scaleFactorDifference + fractionSizeDifference));
                    }
                    else resultFractionBits += (<#= underlyingStructNames[i+1] #>)(<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>leftFraction >> -(biggerPositMovedToLeft + scaleFactorDifference + fractionSizeDifference));

                }
                else if (biggerPositMovedToLeft + scaleFactorDifference + fractionSizeDifference >= 0)
                {
                    resultFractionBits -=(<#= underlyingStructNames[i+1] #>)(<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>leftFraction << (biggerPositMovedToLeft + scaleFactorDifference + fractionSizeDifference));
                }
                else resultFractionBits -=(<#= underlyingStructNames[i+1] #>)(<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>leftFraction >> -(biggerPositMovedToLeft + scaleFactorDifference + fractionSizeDifference));

                scaleFactor += (short)(PositHelper.GetMostSignificantOnePosition(resultFractionBits) - 2 * FirstRegimeBitPosition);
            }
            if (resultFractionBits == 0) return new <#= positStructName #>(0, true);

            var resultRegimeKValue = scaleFactor / (1 << MaximumExponentSize);
            var resultExponentBits = (scaleFactor % (1 << MaximumExponentSize));
            if (resultExponentBits < 0)
            {
                resultRegimeKValue -= 1;
                resultExponentBits += (1 << MaximumExponentSize);
            }

            return new <#= positStructName #>(AssemblePositBitsWithRounding(resultSignBit, resultRegimeKValue, <#= maximumExponentSize==0 
                                                                                                                        ? "" 
                                                                                                                        : "(" + underlyingStructName +")" + " resultExponentBits," #> (<#= underlyingStructNames[i+1] #>)resultFractionBits), true);
        }

        public static <#= positStructName #> operator +(<#= positStructName #> left, int right) => left + new <#= positStructName #>(right);

        public static <#= positStructName #> operator -(<#= positStructName #> left, <#= positStructName #> right) => left + -right;

        public static <#= positStructName #> operator -(<#= positStructName #> left, int right) => left - new <#= positStructName #>(right);

        public static <#= positStructName #> operator -(<#= positStructName #> x)
        {
            if (x.IsNaN() || x.IsZero()) return new <#= positStructName #>(x.PositBits, true);
            return new <#= positStructName #>(GetTwosComplement(x.PositBits), true);
        }

        public static bool operator ==(<#= positStructName #> left, <#= positStructName #> right) => left.PositBits == right.PositBits;

        public static bool operator >(<#= positStructName #> left, <#= positStructName #> right)
        {
            if (left.IsPositive() != right.IsPositive()) return left.IsPositive();
            return left.IsPositive() ? left.PositBits > right.PositBits : !(left.PositBits > right.PositBits);
        }

        public static bool operator <(<#= positStructName #> left, <#= positStructName #> right) => !(left.PositBits > right.PositBits);

        public static bool operator !=(<#= positStructName #> left, <#= positStructName #> right) => !(left == right);

        public static <#= positStructName #> operator *(<#= positStructName #> left, int right) => left * new <#= positStructName #>(right);

        public static <#= positStructName #> operator *(<#= positStructName #> left, <#= positStructName #> right)
        {
            if (left.IsZero() || right.IsZero()) return new <#= positStructName #>(0);
            var leftIsPositive = left.IsPositive();
            var rightIsPositive = right.IsPositive();
            var resultSignBit = leftIsPositive != rightIsPositive;

            left = Abs(left);
            right = Abs(right);
            var leftFractionSize = left.FractionSizeWithoutSignCheck();
            var rightFractionSize = right.FractionSizeWithoutSignCheck();

            <#= underlyingStructNames[i+1] #> longResultFractionBits = (<#= underlyingStructNames[i+1] #>)(<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>left.FractionWithHiddenBitWithoutSignCheck() *
                right.FractionWithHiddenBitWithoutSignCheck());
            var fractionSizeChange = PositHelper.GetMostSignificantOnePosition(longResultFractionBits) - (leftFractionSize + rightFractionSize + 1);
            
            var scaleFactor =
                CalculateScaleFactor(left.GetRegimeKValue()<#= maximumExponentSize==0? "" : ", left.GetExponentValue()" #>, MaximumExponentSize) +
                CalculateScaleFactor(right.GetRegimeKValue()<#= maximumExponentSize==0? "" : ", right.GetExponentValue()" #>, MaximumExponentSize);

            scaleFactor += (int)fractionSizeChange;

            var resultRegimeKValue = scaleFactor / (1 << MaximumExponentSize);
            var resultExponentBits = (scaleFactor % (1 << MaximumExponentSize));
            if (resultExponentBits < 0)
            {
                resultRegimeKValue -= 1;
                resultExponentBits += (1 << MaximumExponentSize);
            }
            return new <#= positStructName #>(AssemblePositBitsWithRounding(resultSignBit, resultRegimeKValue, <#= maximumExponentSize==0 
                                                                                                                        ? "" 
                                                                                                                        : "(" + underlyingStructName +")" + " resultExponentBits," #> longResultFractionBits), true);
        }

        public static <#= positStructName #> operator /(<#= positStructName #> left, int right) => left / new <#= positStructName #>(right);

        public static <#= positStructName #> operator /(<#= positStructName #> left, <#= positStructName #> right)
        {
            if (right.IsZero()) return new <#= positStructName #>(NaNBitMask, true);
            if (left.IsZero()) return new <#= positStructName #>(0);
            
            var leftIsPositive = left.IsPositive();
            var rightIsPositive = right.IsPositive();
            var resultSignBit = leftIsPositive != rightIsPositive;

            left = Abs(left);
            right = Abs(right);
            var leftFractionSize = left.FractionSizeWithoutSignCheck();
            var rightFractionSize = right.FractionSizeWithoutSignCheck();

            var alignedLeftFraction = (<#= underlyingStructNames[i+1] #>)(<#= i >=2 ? "(" + underlyingStructNames[i+1] + ")" : "" #>left.FractionWithHiddenBitWithoutSignCheck() << (int)(2*Size - 1 - leftFractionSize));
            var alignedRightFraction = (<#= underlyingStructName #>)(right.FractionWithHiddenBitWithoutSignCheck() << (int)(Size-1 - rightFractionSize));

            var longResultFractionBits = (<#= underlyingStructNames[i+1] #>)(alignedLeftFraction / alignedRightFraction);
            var remainder = alignedLeftFraction % alignedRightFraction;


            var resultMostSignificantBitPosition = PositHelper.GetMostSignificantOnePosition(longResultFractionBits);

            var fractionSizeChange = resultMostSignificantBitPosition - (Size + 1);

            var scaleFactor =
                CalculateScaleFactor(left.GetRegimeKValue()<#= maximumExponentSize==0? "" : ", left.GetExponentValue()" #>, MaximumExponentSize) -
                CalculateScaleFactor(right.GetRegimeKValue()<#= maximumExponentSize==0? "" : ", right.GetExponentValue()" #>, MaximumExponentSize);
            scaleFactor += fractionSizeChange;

            var resultRegimeKValue = scaleFactor / (1 << MaximumExponentSize);
            
            if (remainder != 0)
            {
                longResultFractionBits <<= (2 * Size - resultMostSignificantBitPosition);
                longResultFractionBits += 1;

            }

            var resultExponentBits = (scaleFactor % (1 << MaximumExponentSize));
            if (resultExponentBits < 0)
            {
                resultRegimeKValue -= 1;
                resultExponentBits += (1 << MaximumExponentSize);
            }			

            return new <#= positStructName #>(AssemblePositBitsWithRounding(resultSignBit, resultRegimeKValue, <#= maximumExponentSize==0 
                                                                                                                        ? "" 
                                                                                                                        : "(" + underlyingStructName +")" + " resultExponentBits," #> longResultFractionBits), true);
        }

        #endregion

        #region Conversion Operators 
    
        public static explicit operator int(<#= positStructName #> x)
        {
            uint result;
            if (x.PositBits == 0) return 0;

            var scaleFactor = x.GetRegimeKValue() * (1 << MaximumExponentSize)<#= maximumExponentSize==0? "" : " + x.GetExponentValue()" #>;

            if (scaleFactor + 1 <= 31) // The posit fits into the range
            {
                var mostSignificantOnePosition = PositHelper.GetMostSignificantOnePosition(x.FractionWithHiddenBit());

                if (scaleFactor - mostSignificantOnePosition + 1 >= 0)
                {
                    result = (uint)(x.FractionWithHiddenBit() <<
                        (int)(scaleFactor - mostSignificantOnePosition + 1));
                }
                else
                {
                    result = (uint)(x.FractionWithHiddenBit() >>
                               -(int)(scaleFactor - mostSignificantOnePosition + 1));
                }
            }
            else return (x.IsPositive()) ? int.MaxValue : int.MinValue;

            return x.IsPositive() ? (int)result : (int)-result;
        }

        public static explicit operator float(<#= positStructName #> x)
        {
            if (x.IsNaN()) return float.NaN;
            if (x.IsZero()) return 0F;

            var floatBits = x.IsPositive() ? 0: Float32SignBitMask;
            float floatRepresentation;
            var scaleFactor = x.GetRegimeKValue() * (1 << MaximumExponentSize)<#= maximumExponentSize==0? "" : " + x.GetExponentValue()" #>;

            if (scaleFactor > 127) return x.IsPositive() ? float.MaxValue : float.MinValue;
            if (scaleFactor < -127) return x.IsPositive() ? float.Epsilon : -float.Epsilon;

            var fraction = x.Fraction();

            if (scaleFactor == -127)
            {
                fraction >>= 1;
                fraction += (Float32HiddenBitMask >> 1);
            }

            floatBits += (uint)((scaleFactor + 127) << 23);

            if (x.FractionSize() <= 23)
            {
                fraction <<= (int)(23 - x.FractionSize());
            }
            else
            {
                fraction >>= (int)-(23 - x.FractionSize());
            }

            floatBits += (fraction << (32 - PositHelper.GetMostSignificantOnePosition(fraction) - 1)) >> (32 - PositHelper.GetMostSignificantOnePosition(fraction) - 1);

            unsafe
            {
                float* floatPointer = (float*)&floatBits;
                floatRepresentation = *floatPointer;
            }

            return floatRepresentation;
        }

        public static explicit operator double(<#= positStructName #> x)
        {
            if (x.IsNaN()) return double.NaN;
            if (x.IsZero()) return 0D;

            ulong doubleBits = x.IsPositive() ? EmptyBitMask : ((ulong)SignBitMask) << 64-Size;
            double doubleRepresentation;
            long scaleFactor = x.GetRegimeKValue() * (1 << MaximumExponentSize)<#= maximumExponentSize==0? "" : " + x.GetExponentValue()" #>;

            var fraction = x.Fraction();
            var longFraction = (ulong) fraction;

            doubleBits += (ulong)((scaleFactor + 1023) << 52);

            longFraction <<= (int)(52 - x.FractionSize());
            doubleBits += (longFraction << (64 - PositHelper.GetMostSignificantOnePosition(longFraction) - 1)) >> (64 - PositHelper.GetMostSignificantOnePosition(longFraction) - 1);

            unsafe
            {
                double* doublePointer = (double*)&doubleBits;
                doubleRepresentation = *doublePointer;
            }
            return doubleRepresentation;
        }

        public static explicit operator Quire(<#= positStructName #> x)
        {
            if (x.IsNaN()) return new Quire(1, QuireSize) << QuireSize-1;
            if (x.IsZero()) return new Quire(0, QuireSize);
            var quireArray = new ulong[QuireSize / 64];
            quireArray[0] = x.FractionWithHiddenBit();
            var resultQuire = new Quire(quireArray);
            resultQuire <<= (int)(QuireFractionSize - x.FractionSize() + x.CalculateScaleFactor());
            return x.IsPositive() ? resultQuire : (~resultQuire) + 1;
        }

        #endregion

        #region Conversions to other Posit environments

<# for (var n = 0; n<3; n++){ 
    for(var MaxEs = 0; MaxEs<=4; MaxEs++){
        var destinationpositStructName = PositTemplateHelper.GetPositStructName(positSizes[n], MaxEs);
        if (destinationpositStructName == positStructName) continue; #>
        public static explicit operator <#= destinationpositStructName #>(<#= positStructName #> x)
        {
            if (x.IsNaN()) return new <#= destinationpositStructName #>(<#= destinationpositStructName #>.NaNBitMask, true);
            if (x.IsZero()) return new <#= destinationpositStructName #>(0, true);

            var fractionSizeWithHiddenBit = x.FractionSize() + 1;
            return new <#= destinationpositStructName #>(!x.IsPositive(), x.CalculateScaleFactor(), x.FractionWithHiddenBit());
        }

    <# } #>
<# } #>
        #endregion

        #region Support methods

        public int CompareTo(Object value)
        {
            switch (value)
            {
                case null:
                    return 1;
                case <#= positStructName #>  posit:
                    return CompareTo(posit);
                default: throw new ArgumentException("Argument must be an other posit.");
            }            
        }

        public int CompareTo(<#= positStructName #>  value)
        {
            if (this < value) return -1;
            if (this > value) return 1;
            if (this == value) return 0;

            // At least one of the values is NaN.
            if (IsNaN()) return (value.IsNaN() ? 0 : -1);
            else return 1;
        }

        // The value of every 32-bit posit can be exactly represented by a double, so using the double's ToString() and
        // Parse() methods will make code generation more consistent.
        public override string ToString() => ((double)this).ToString();

        public string ToString(string format, IFormatProvider formatProvider) => ((double)this).ToString(format, formatProvider);

        public string ToString(IFormatProvider provider) => ((double)this).ToString(provider);

        public override int GetHashCode() => (int)PositBits;

        public <#= positStructName #>  Parse(string number) => new <#= positStructName #>(Double.Parse(number));

        public bool TryParse(string number, out <#= positStructName #>  positResult)
        {
            var returnValue = Double.TryParse(number, out double result);
            positResult = new <#= positStructName #> (result);
            return returnValue;
        }

        public bool Equals(<#= positStructName #>  other) => (this == other);

        public override bool Equals(object obj) => (obj is <#= positStructName #>  posit) ? Equals(posit) : false;
        
        public TypeCode GetTypeCode() => TypeCode.Object;

        public bool ToBoolean(IFormatProvider provider) => !IsZero();

        public char ToChar(IFormatProvider provider) => throw new InvalidCastException();

        public sbyte ToSByte(IFormatProvider provider) => (sbyte)(int)this;

        public byte ToByte(IFormatProvider provider) => (byte)(uint)this;

        public short ToInt16(IFormatProvider provider) => (short)(int)this;

        public ushort ToUInt16(IFormatProvider provider) => (ushort)(uint)this;

        public int ToInt32(IFormatProvider provider) => (int)this;

        public uint ToUInt32(IFormatProvider provider) => (uint)this;

        public long ToInt64(IFormatProvider provider) => (long)this;

        public ulong ToUInt64(IFormatProvider provider) => (ulong)this;

        public float ToSingle(IFormatProvider provider) => (float)this;

        public double ToDouble(IFormatProvider provider) => (double)this;

        public decimal ToDecimal(IFormatProvider provider) => throw new InvalidCastException();

        public DateTime ToDateTime(IFormatProvider provider) => throw new InvalidCastException();

        public object ToType(Type conversionType, IFormatProvider provider) => throw new InvalidCastException();

        #endregion
    }
}
<# 
    }
}

templateFileManager.Process();
#>
